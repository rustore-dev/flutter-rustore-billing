// Autogenerated from Pigeon (v4.2.10), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

class SubscriptionPeriod {
  SubscriptionPeriod({
    required this.years,
    required this.months,
    required this.days,
  });

  int years;
  int months;
  int days;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['years'] = years;
    pigeonMap['months'] = months;
    pigeonMap['days'] = days;
    return pigeonMap;
  }

  static SubscriptionPeriod decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SubscriptionPeriod(
      years: pigeonMap['years']! as int,
      months: pigeonMap['months']! as int,
      days: pigeonMap['days']! as int,
    );
  }
}

class Subscription {
  Subscription({
    this.subscriptionPeriod,
    this.freeTrialPeriod,
    this.gracePeriod,
    this.introductoryPrice,
    this.introductoryPriceAmount,
    this.introductoryPricePeriod,
  });

  SubscriptionPeriod? subscriptionPeriod;
  SubscriptionPeriod? freeTrialPeriod;
  SubscriptionPeriod? gracePeriod;
  String? introductoryPrice;
  String? introductoryPriceAmount;
  SubscriptionPeriod? introductoryPricePeriod;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['subscriptionPeriod'] = subscriptionPeriod?.encode();
    pigeonMap['freeTrialPeriod'] = freeTrialPeriod?.encode();
    pigeonMap['gracePeriod'] = gracePeriod?.encode();
    pigeonMap['introductoryPrice'] = introductoryPrice;
    pigeonMap['introductoryPriceAmount'] = introductoryPriceAmount;
    pigeonMap['introductoryPricePeriod'] = introductoryPricePeriod?.encode();
    return pigeonMap;
  }

  static Subscription decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Subscription(
      subscriptionPeriod: pigeonMap['subscriptionPeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['subscriptionPeriod']!)
          : null,
      freeTrialPeriod: pigeonMap['freeTrialPeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['freeTrialPeriod']!)
          : null,
      gracePeriod: pigeonMap['gracePeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['gracePeriod']!)
          : null,
      introductoryPrice: pigeonMap['introductoryPrice'] as String?,
      introductoryPriceAmount: pigeonMap['introductoryPriceAmount'] as String?,
      introductoryPricePeriod: pigeonMap['introductoryPricePeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['introductoryPricePeriod']!)
          : null,
    );
  }
}

class Product {
  Product({
    required this.productId,
    this.productType,
    required this.productStatus,
    this.priceLabel,
    this.price,
    this.currency,
    this.language,
    this.title,
    this.description,
    this.imageUrl,
    this.promoImageUrl,
    this.subscription,
  });

  String productId;
  String? productType;
  String productStatus;
  String? priceLabel;
  int? price;
  String? currency;
  String? language;
  String? title;
  String? description;
  String? imageUrl;
  String? promoImageUrl;
  Subscription? subscription;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['productId'] = productId;
    pigeonMap['productType'] = productType;
    pigeonMap['productStatus'] = productStatus;
    pigeonMap['priceLabel'] = priceLabel;
    pigeonMap['price'] = price;
    pigeonMap['currency'] = currency;
    pigeonMap['language'] = language;
    pigeonMap['title'] = title;
    pigeonMap['description'] = description;
    pigeonMap['imageUrl'] = imageUrl;
    pigeonMap['promoImageUrl'] = promoImageUrl;
    pigeonMap['subscription'] = subscription?.encode();
    return pigeonMap;
  }

  static Product decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Product(
      productId: pigeonMap['productId']! as String,
      productType: pigeonMap['productType'] as String?,
      productStatus: pigeonMap['productStatus']! as String,
      priceLabel: pigeonMap['priceLabel'] as String?,
      price: pigeonMap['price'] as int?,
      currency: pigeonMap['currency'] as String?,
      language: pigeonMap['language'] as String?,
      title: pigeonMap['title'] as String?,
      description: pigeonMap['description'] as String?,
      imageUrl: pigeonMap['imageUrl'] as String?,
      promoImageUrl: pigeonMap['promoImageUrl'] as String?,
      subscription: pigeonMap['subscription'] != null
          ? Subscription.decode(pigeonMap['subscription']!)
          : null,
    );
  }
}

class ProductsResponse {
  ProductsResponse({
    required this.code,
    this.errorMessage,
    this.errorDescription,
    this.traceId,
    required this.products,
    required this.errors,
  });

  int code;
  String? errorMessage;
  String? errorDescription;
  String? traceId;
  List<Product?> products;
  List<DigitalShopGeneralError?> errors;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['errorMessage'] = errorMessage;
    pigeonMap['errorDescription'] = errorDescription;
    pigeonMap['traceId'] = traceId;
    pigeonMap['products'] = products;
    pigeonMap['errors'] = errors;
    return pigeonMap;
  }

  static ProductsResponse decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ProductsResponse(
      code: pigeonMap['code']! as int,
      errorMessage: pigeonMap['errorMessage'] as String?,
      errorDescription: pigeonMap['errorDescription'] as String?,
      traceId: pigeonMap['traceId'] as String?,
      products: (pigeonMap['products'] as List<Object?>?)!.cast<Product?>(),
      errors: (pigeonMap['errors'] as List<Object?>?)!.cast<DigitalShopGeneralError?>(),
    );
  }
}

class Purchase {
  Purchase({
    this.purchaseId,
    this.productId,
    this.description,
    this.language,
    this.purchaseTime,
    this.orderId,
    this.amountLabel,
    this.amount,
    this.currency,
    this.quantity,
    this.purchaseState,
    this.developerPayload,
  });

  String? purchaseId;
  String? productId;
  String? description;
  String? language;
  String? purchaseTime;
  String? orderId;
  String? amountLabel;
  int? amount;
  String? currency;
  int? quantity;
  String? purchaseState;
  String? developerPayload;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['purchaseId'] = purchaseId;
    pigeonMap['productId'] = productId;
    pigeonMap['description'] = description;
    pigeonMap['language'] = language;
    pigeonMap['purchaseTime'] = purchaseTime;
    pigeonMap['orderId'] = orderId;
    pigeonMap['amountLabel'] = amountLabel;
    pigeonMap['amount'] = amount;
    pigeonMap['currency'] = currency;
    pigeonMap['quantity'] = quantity;
    pigeonMap['purchaseState'] = purchaseState;
    pigeonMap['developerPayload'] = developerPayload;
    return pigeonMap;
  }

  static Purchase decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Purchase(
      purchaseId: pigeonMap['purchaseId'] as String?,
      productId: pigeonMap['productId'] as String?,
      description: pigeonMap['description'] as String?,
      language: pigeonMap['language'] as String?,
      purchaseTime: pigeonMap['purchaseTime'] as String?,
      orderId: pigeonMap['orderId'] as String?,
      amountLabel: pigeonMap['amountLabel'] as String?,
      amount: pigeonMap['amount'] as int?,
      currency: pigeonMap['currency'] as String?,
      quantity: pigeonMap['quantity'] as int?,
      purchaseState: pigeonMap['purchaseState'] as String?,
      developerPayload: pigeonMap['developerPayload'] as String?,
    );
  }
}

class PurchasesResponse {
  PurchasesResponse({
    required this.code,
    this.errorMessage,
    this.errorDescription,
    this.traceId,
    required this.purchases,
    required this.errors,
  });

  int code;
  String? errorMessage;
  String? errorDescription;
  String? traceId;
  List<Purchase?> purchases;
  List<DigitalShopGeneralError?> errors;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['errorMessage'] = errorMessage;
    pigeonMap['errorDescription'] = errorDescription;
    pigeonMap['traceId'] = traceId;
    pigeonMap['purchases'] = purchases;
    pigeonMap['errors'] = errors;
    return pigeonMap;
  }

  static PurchasesResponse decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PurchasesResponse(
      code: pigeonMap['code']! as int,
      errorMessage: pigeonMap['errorMessage'] as String?,
      errorDescription: pigeonMap['errorDescription'] as String?,
      traceId: pigeonMap['traceId'] as String?,
      purchases: (pigeonMap['purchases'] as List<Object?>?)!.cast<Purchase?>(),
      errors: (pigeonMap['errors'] as List<Object?>?)!.cast<DigitalShopGeneralError?>(),
    );
  }
}

class ConfirmPurchaseResponse {
  ConfirmPurchaseResponse({
    required this.code,
    this.errorMessage,
    this.errorDescription,
    this.traceId,
    required this.errors,
  });

  int code;
  String? errorMessage;
  String? errorDescription;
  String? traceId;
  List<DigitalShopGeneralError?> errors;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['errorMessage'] = errorMessage;
    pigeonMap['errorDescription'] = errorDescription;
    pigeonMap['traceId'] = traceId;
    pigeonMap['errors'] = errors;
    return pigeonMap;
  }

  static ConfirmPurchaseResponse decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConfirmPurchaseResponse(
      code: pigeonMap['code']! as int,
      errorMessage: pigeonMap['errorMessage'] as String?,
      errorDescription: pigeonMap['errorDescription'] as String?,
      traceId: pigeonMap['traceId'] as String?,
      errors: (pigeonMap['errors'] as List<Object?>?)!.cast<DigitalShopGeneralError?>(),
    );
  }
}

class PaymentResult {
  PaymentResult({
    this.successInvoice,
    this.invalidInvoice,
    this.successPurchase,
    this.invalidPurchase,
  });

  SuccessInvoice? successInvoice;
  InvalidInvoice? invalidInvoice;
  SuccessPurchase? successPurchase;
  InvalidPurchase? invalidPurchase;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['successInvoice'] = successInvoice?.encode();
    pigeonMap['invalidInvoice'] = invalidInvoice?.encode();
    pigeonMap['successPurchase'] = successPurchase?.encode();
    pigeonMap['invalidPurchase'] = invalidPurchase?.encode();
    return pigeonMap;
  }

  static PaymentResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PaymentResult(
      successInvoice: pigeonMap['successInvoice'] != null
          ? SuccessInvoice.decode(pigeonMap['successInvoice']!)
          : null,
      invalidInvoice: pigeonMap['invalidInvoice'] != null
          ? InvalidInvoice.decode(pigeonMap['invalidInvoice']!)
          : null,
      successPurchase: pigeonMap['successPurchase'] != null
          ? SuccessPurchase.decode(pigeonMap['successPurchase']!)
          : null,
      invalidPurchase: pigeonMap['invalidPurchase'] != null
          ? InvalidPurchase.decode(pigeonMap['invalidPurchase']!)
          : null,
    );
  }
}

class SuccessInvoice {
  SuccessInvoice({
    required this.invoiceId,
    required this.finishCode,
  });

  String invoiceId;
  String finishCode;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['invoiceId'] = invoiceId;
    pigeonMap['finishCode'] = finishCode;
    return pigeonMap;
  }

  static SuccessInvoice decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SuccessInvoice(
      invoiceId: pigeonMap['invoiceId']! as String,
      finishCode: pigeonMap['finishCode']! as String,
    );
  }
}

class InvalidInvoice {
  InvalidInvoice({
    this.invoiceId,
  });

  String? invoiceId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['invoiceId'] = invoiceId;
    return pigeonMap;
  }

  static InvalidInvoice decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return InvalidInvoice(
      invoiceId: pigeonMap['invoiceId'] as String?,
    );
  }
}

class SuccessPurchase {
  SuccessPurchase({
    required this.finishCode,
    this.orderId,
    required this.purchaseId,
    required this.productId,
  });

  String finishCode;
  String? orderId;
  String purchaseId;
  String productId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['finishCode'] = finishCode;
    pigeonMap['orderId'] = orderId;
    pigeonMap['purchaseId'] = purchaseId;
    pigeonMap['productId'] = productId;
    return pigeonMap;
  }

  static SuccessPurchase decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SuccessPurchase(
      finishCode: pigeonMap['finishCode']! as String,
      orderId: pigeonMap['orderId'] as String?,
      purchaseId: pigeonMap['purchaseId']! as String,
      productId: pigeonMap['productId']! as String,
    );
  }
}

class InvalidPurchase {
  InvalidPurchase({
    this.purchaseId,
    this.invoiceId,
    this.orderId,
    this.quantity,
    this.productId,
    this.errorCode,
  });

  String? purchaseId;
  String? invoiceId;
  String? orderId;
  int? quantity;
  String? productId;
  int? errorCode;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['purchaseId'] = purchaseId;
    pigeonMap['invoiceId'] = invoiceId;
    pigeonMap['orderId'] = orderId;
    pigeonMap['quantity'] = quantity;
    pigeonMap['productId'] = productId;
    pigeonMap['errorCode'] = errorCode;
    return pigeonMap;
  }

  static InvalidPurchase decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return InvalidPurchase(
      purchaseId: pigeonMap['purchaseId'] as String?,
      invoiceId: pigeonMap['invoiceId'] as String?,
      orderId: pigeonMap['orderId'] as String?,
      quantity: pigeonMap['quantity'] as int?,
      productId: pigeonMap['productId'] as String?,
      errorCode: pigeonMap['errorCode'] as int?,
    );
  }
}

class DigitalShopGeneralError {
  DigitalShopGeneralError({
    this.name,
    this.code,
    this.description,
  });

  String? name;
  int? code;
  String? description;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['name'] = name;
    pigeonMap['code'] = code;
    pigeonMap['description'] = description;
    return pigeonMap;
  }

  static DigitalShopGeneralError decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return DigitalShopGeneralError(
      name: pigeonMap['name'] as String?,
      code: pigeonMap['code'] as int?,
      description: pigeonMap['description'] as String?,
    );
  }
}

class _ClientCodec extends StandardMessageCodec{
  const _ClientCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ConfirmPurchaseResponse) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is DigitalShopGeneralError) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is InvalidInvoice) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is InvalidPurchase) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is PaymentResult) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is Product) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is ProductsResponse) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
    if (value is Purchase) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else 
    if (value is PurchasesResponse) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else 
    if (value is Subscription) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else 
    if (value is SubscriptionPeriod) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else 
    if (value is SuccessInvoice) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else 
    if (value is SuccessPurchase) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ConfirmPurchaseResponse.decode(readValue(buffer)!);
      
      case 129:       
        return DigitalShopGeneralError.decode(readValue(buffer)!);
      
      case 130:       
        return InvalidInvoice.decode(readValue(buffer)!);
      
      case 131:       
        return InvalidPurchase.decode(readValue(buffer)!);
      
      case 132:       
        return PaymentResult.decode(readValue(buffer)!);
      
      case 133:       
        return Product.decode(readValue(buffer)!);
      
      case 134:       
        return ProductsResponse.decode(readValue(buffer)!);
      
      case 135:       
        return Purchase.decode(readValue(buffer)!);
      
      case 136:       
        return PurchasesResponse.decode(readValue(buffer)!);
      
      case 137:       
        return Subscription.decode(readValue(buffer)!);
      
      case 138:       
        return SubscriptionPeriod.decode(readValue(buffer)!);
      
      case 139:       
        return SuccessInvoice.decode(readValue(buffer)!);
      
      case 140:       
        return SuccessPurchase.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class Client {
  /// Constructor for [Client].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Client({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ClientCodec();

  Future<String> initialize(String arg_id, String arg_prefix) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.initialize', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_id, arg_prefix]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<bool> available() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.available', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<ProductsResponse> products(List<String?> arg_ids) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.products', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_ids]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ProductsResponse?)!;
    }
  }

  Future<PurchasesResponse> purchases() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.purchases', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as PurchasesResponse?)!;
    }
  }

  Future<PaymentResult> purchase(String arg_id) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.purchase', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_id]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as PaymentResult?)!;
    }
  }

  Future<ConfirmPurchaseResponse> confirm(String arg_id) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.confirm', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_id]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ConfirmPurchaseResponse?)!;
    }
  }
}
