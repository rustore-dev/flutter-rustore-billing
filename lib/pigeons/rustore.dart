// Autogenerated from Pigeon (v4.2.10), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

class SubscriptionPeriod {
  SubscriptionPeriod({
    required this.years,
    required this.months,
    required this.days,
  });

  int years;
  int months;
  int days;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['years'] = years;
    pigeonMap['months'] = months;
    pigeonMap['days'] = days;
    return pigeonMap;
  }

  static SubscriptionPeriod decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return SubscriptionPeriod(
      years: pigeonMap['years']! as int,
      months: pigeonMap['months']! as int,
      days: pigeonMap['days']! as int,
    );
  }
}

class Subscription {
  Subscription({
    this.subscriptionPeriod,
    this.freeTrialPeriod,
    this.gracePeriod,
    this.introductoryPrice,
    this.introductoryPriceAmount,
    this.introductoryPricePeriod,
  });

  SubscriptionPeriod? subscriptionPeriod;
  SubscriptionPeriod? freeTrialPeriod;
  SubscriptionPeriod? gracePeriod;
  String? introductoryPrice;
  String? introductoryPriceAmount;
  SubscriptionPeriod? introductoryPricePeriod;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['subscriptionPeriod'] = subscriptionPeriod?.encode();
    pigeonMap['freeTrialPeriod'] = freeTrialPeriod?.encode();
    pigeonMap['gracePeriod'] = gracePeriod?.encode();
    pigeonMap['introductoryPrice'] = introductoryPrice;
    pigeonMap['introductoryPriceAmount'] = introductoryPriceAmount;
    pigeonMap['introductoryPricePeriod'] = introductoryPricePeriod?.encode();
    return pigeonMap;
  }

  static Subscription decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Subscription(
      subscriptionPeriod: pigeonMap['subscriptionPeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['subscriptionPeriod']!)
          : null,
      freeTrialPeriod: pigeonMap['freeTrialPeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['freeTrialPeriod']!)
          : null,
      gracePeriod: pigeonMap['gracePeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['gracePeriod']!)
          : null,
      introductoryPrice: pigeonMap['introductoryPrice'] as String?,
      introductoryPriceAmount: pigeonMap['introductoryPriceAmount'] as String?,
      introductoryPricePeriod: pigeonMap['introductoryPricePeriod'] != null
          ? SubscriptionPeriod.decode(pigeonMap['introductoryPricePeriod']!)
          : null,
    );
  }
}

class Product {
  Product({
    required this.id,
    this.type,
    required this.status,
    this.label,
    this.price,
    this.currency,
    this.language,
    this.title,
    this.description,
    this.image,
    this.promo,
    this.subscription,
  });

  String id;
  String? type;
  String status;
  String? label;
  int? price;
  String? currency;
  String? language;
  String? title;
  String? description;
  String? image;
  String? promo;
  Subscription? subscription;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['id'] = id;
    pigeonMap['type'] = type;
    pigeonMap['status'] = status;
    pigeonMap['label'] = label;
    pigeonMap['price'] = price;
    pigeonMap['currency'] = currency;
    pigeonMap['language'] = language;
    pigeonMap['title'] = title;
    pigeonMap['description'] = description;
    pigeonMap['image'] = image;
    pigeonMap['promo'] = promo;
    pigeonMap['subscription'] = subscription?.encode();
    return pigeonMap;
  }

  static Product decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Product(
      id: pigeonMap['id']! as String,
      type: pigeonMap['type'] as String?,
      status: pigeonMap['status']! as String,
      label: pigeonMap['label'] as String?,
      price: pigeonMap['price'] as int?,
      currency: pigeonMap['currency'] as String?,
      language: pigeonMap['language'] as String?,
      title: pigeonMap['title'] as String?,
      description: pigeonMap['description'] as String?,
      image: pigeonMap['image'] as String?,
      promo: pigeonMap['promo'] as String?,
      subscription: pigeonMap['subscription'] != null
          ? Subscription.decode(pigeonMap['subscription']!)
          : null,
    );
  }
}

class ProductsResponse {
  ProductsResponse({
    required this.code,
    this.errorMessage,
    this.errorDescription,
    this.traceId,
    required this.products,
  });

  int code;
  String? errorMessage;
  String? errorDescription;
  String? traceId;
  List<Product?> products;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['errorMessage'] = errorMessage;
    pigeonMap['errorDescription'] = errorDescription;
    pigeonMap['traceId'] = traceId;
    pigeonMap['products'] = products;
    return pigeonMap;
  }

  static ProductsResponse decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ProductsResponse(
      code: pigeonMap['code']! as int,
      errorMessage: pigeonMap['errorMessage'] as String?,
      errorDescription: pigeonMap['errorDescription'] as String?,
      traceId: pigeonMap['traceId'] as String?,
      products: (pigeonMap['products'] as List<Object?>?)!.cast<Product?>(),
    );
  }
}

class Purchase {
  Purchase({
    this.purchaseId,
    required this.productId,
    this.description,
    this.language,
    this.purchaseTime,
    this.orderId,
    this.amountLabel,
    this.amount,
    this.currency,
    this.quantity,
    this.state,
    this.payload,
  });

  String? purchaseId;
  String productId;
  String? description;
  String? language;
  String? purchaseTime;
  String? orderId;
  String? amountLabel;
  int? amount;
  String? currency;
  int? quantity;
  String? state;
  String? payload;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['purchaseId'] = purchaseId;
    pigeonMap['productId'] = productId;
    pigeonMap['description'] = description;
    pigeonMap['language'] = language;
    pigeonMap['purchaseTime'] = purchaseTime;
    pigeonMap['orderId'] = orderId;
    pigeonMap['amountLabel'] = amountLabel;
    pigeonMap['amount'] = amount;
    pigeonMap['currency'] = currency;
    pigeonMap['quantity'] = quantity;
    pigeonMap['state'] = state;
    pigeonMap['payload'] = payload;
    return pigeonMap;
  }

  static Purchase decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Purchase(
      purchaseId: pigeonMap['purchaseId'] as String?,
      productId: pigeonMap['productId']! as String,
      description: pigeonMap['description'] as String?,
      language: pigeonMap['language'] as String?,
      purchaseTime: pigeonMap['purchaseTime'] as String?,
      orderId: pigeonMap['orderId'] as String?,
      amountLabel: pigeonMap['amountLabel'] as String?,
      amount: pigeonMap['amount'] as int?,
      currency: pigeonMap['currency'] as String?,
      quantity: pigeonMap['quantity'] as int?,
      state: pigeonMap['state'] as String?,
      payload: pigeonMap['payload'] as String?,
    );
  }
}

class PurchasesResponse {
  PurchasesResponse({
    required this.code,
    required this.errorMessage,
    required this.errorDescription,
    required this.traceId,
    required this.purchases,
  });

  int code;
  String errorMessage;
  String errorDescription;
  String traceId;
  List<Purchase?> purchases;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['errorMessage'] = errorMessage;
    pigeonMap['errorDescription'] = errorDescription;
    pigeonMap['traceId'] = traceId;
    pigeonMap['purchases'] = purchases;
    return pigeonMap;
  }

  static PurchasesResponse decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PurchasesResponse(
      code: pigeonMap['code']! as int,
      errorMessage: pigeonMap['errorMessage']! as String,
      errorDescription: pigeonMap['errorDescription']! as String,
      traceId: pigeonMap['traceId']! as String,
      purchases: (pigeonMap['purchases'] as List<Object?>?)!.cast<Purchase?>(),
    );
  }
}

class ConfirmPurchaseResponse {
  ConfirmPurchaseResponse({
    required this.code,
  });

  int code;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    return pigeonMap;
  }

  static ConfirmPurchaseResponse decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConfirmPurchaseResponse(
      code: pigeonMap['code']! as int,
    );
  }
}

class PaymentResult {
  PaymentResult({
    required this.code,
  });

  int code;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    return pigeonMap;
  }

  static PaymentResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PaymentResult(
      code: pigeonMap['code']! as int,
    );
  }
}

class _ClientCodec extends StandardMessageCodec{
  const _ClientCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ConfirmPurchaseResponse) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is PaymentResult) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is Product) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is ProductsResponse) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is Purchase) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is PurchasesResponse) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is Subscription) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
    if (value is SubscriptionPeriod) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ConfirmPurchaseResponse.decode(readValue(buffer)!);
      
      case 129:       
        return PaymentResult.decode(readValue(buffer)!);
      
      case 130:       
        return Product.decode(readValue(buffer)!);
      
      case 131:       
        return ProductsResponse.decode(readValue(buffer)!);
      
      case 132:       
        return Purchase.decode(readValue(buffer)!);
      
      case 133:       
        return PurchasesResponse.decode(readValue(buffer)!);
      
      case 134:       
        return Subscription.decode(readValue(buffer)!);
      
      case 135:       
        return SubscriptionPeriod.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class Client {
  /// Constructor for [Client].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Client({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ClientCodec();

  Future<String> initialize(String arg_id, String arg_prefix) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.initialize', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_id, arg_prefix]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<bool> available() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.available', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<ProductsResponse> products(List<String?> arg_ids) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.products', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_ids]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ProductsResponse?)!;
    }
  }

  Future<PurchasesResponse> purchases() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.purchases', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as PurchasesResponse?)!;
    }
  }

  Future<PaymentResult> purchase(String arg_id) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.purchase', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_id]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as PaymentResult?)!;
    }
  }

  Future<ConfirmPurchaseResponse> confirm(String arg_id) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.Client.confirm', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_id]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ConfirmPurchaseResponse?)!;
    }
  }
}
